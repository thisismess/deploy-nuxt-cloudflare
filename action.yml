name: 'Deploy Nuxt to Cloudflare Workers'
description: 'Build and deploy a Nuxt application to Cloudflare Workers with versioned deployments'
author: 'This is Mess'

branding:
  icon: 'upload-cloud'
  color: 'orange'

inputs:
  cloudflare-api-token:
    description: 'Cloudflare API Token with Workers permissions'
    required: true
  cloudflare-account-id:
    description: 'Cloudflare Account ID'
    required: true
  worker-name:
    description: 'Name of the Cloudflare Worker'
    required: true
  working-directory:
    description: 'Path to Nuxt project directory'
    default: '.'
  node-version:
    description: 'Node.js version to use'
    default: '20'
  build-command:
    description: 'Command to build the Nuxt app'
    default: 'npm run build'
  install-command:
    description: 'Command to install dependencies'
    default: 'npm ci'
  package-manager:
    description: 'Package manager to use for caching (npm, pnpm, yarn, or none to disable caching)'
    default: 'npm'
  build-env:
    description: 'JSON object of environment variables for build step'
    required: false
    default: '{}'
  secrets-json:
    description: 'JSON object of secrets to upload to Cloudflare Worker'
    required: false
  deploy-tag:
    description: 'Tag for the deployment (defaults to short SHA)'
    required: false
  deploy-message:
    description: 'Message for the deployment'
    required: false
  github-environment:
    description: 'GitHub environment name - merges wrangler.{github-environment}.jsonc into base config if it exists'
    required: false
  mode:
    description: 'Action mode: full (build+deploy), build (upload only), or deploy (deploy existing version)'
    required: false
    default: 'full'
  version-id:
    description: 'Worker Version ID to deploy (required when mode is deploy)'
    required: false

outputs:
  version-id:
    description: 'The uploaded/deployed Worker Version ID'
    value: ${{ steps.upload.outputs.version-id || inputs.version-id }}
  deploy-tag:
    description: 'The tag used for the deployment'
    value: ${{ steps.vars.outputs.tag }}

runs:
  using: 'composite'
  steps:
    - name: Determine lockfile path
      if: (inputs.mode == 'full' || inputs.mode == 'build') && inputs.package-manager != 'none'
      id: lockfile
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        if [ "${{ inputs.package-manager }}" == "pnpm" ]; then
          echo "path=${{ inputs.working-directory }}/pnpm-lock.yaml" >> $GITHUB_OUTPUT
        elif [ "${{ inputs.package-manager }}" == "yarn" ]; then
          echo "path=${{ inputs.working-directory }}/yarn.lock" >> $GITHUB_OUTPUT
        else
          echo "path=${{ inputs.working-directory }}/package-lock.json" >> $GITHUB_OUTPUT
        fi

    - name: Setup pnpm
      if: (inputs.mode == 'full' || inputs.mode == 'build') && inputs.package-manager == 'pnpm'
      uses: pnpm/action-setup@v4
      with:
        version: latest

    - name: Setup Node.js
      if: inputs.mode == 'full' || inputs.mode == 'build'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        cache: ${{ inputs.package-manager != 'none' && inputs.package-manager || '' }}
        cache-dependency-path: ${{ steps.lockfile.outputs.path }}

    - name: Install dependencies
      if: inputs.mode == 'full' || inputs.mode == 'build'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Auto-detect install command based on package manager if using default
        INSTALL_CMD="${{ inputs.install-command }}"
        if [ "$INSTALL_CMD" == "npm ci" ]; then
          case "${{ inputs.package-manager }}" in
            pnpm) INSTALL_CMD="pnpm install --frozen-lockfile" ;;
            yarn) INSTALL_CMD="yarn install --frozen-lockfile" ;;
          esac
        fi
        $INSTALL_CMD

    - name: Parse build environment variables
      if: inputs.mode == 'full' || inputs.mode == 'build'
      id: build-env
      shell: bash
      run: |
        # Parse JSON and export as environment variables
        echo '${{ inputs.build-env }}' | jq -r 'to_entries | .[] | "export \(.key)=\"\(.value)\""' > /tmp/build-env.sh || true

    - name: Build Worker
      if: inputs.mode == 'full' || inputs.mode == 'build'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Source build environment variables if they exist
        if [ -f /tmp/build-env.sh ]; then
          source /tmp/build-env.sh
        fi
        ${{ inputs.build-command }}

    - name: Set deployment variables
      if: inputs.mode == 'full' || inputs.mode == 'build'
      id: vars
      shell: bash
      run: |
        # Use provided tag or default to short SHA
        if [ -n "${{ inputs.deploy-tag }}" ]; then
          echo "tag=${{ inputs.deploy-tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
        fi

        # Use provided message or default
        if [ -n "${{ inputs.deploy-message }}" ]; then
          echo "message=${{ inputs.deploy-message }}" >> $GITHUB_OUTPUT
        else
          echo "message=${{ github.actor }} - ${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
        fi

    - name: Merge wrangler config for environment
      id: wrangler-config
      if: inputs.github-environment != '' && (inputs.mode == 'full' || inputs.mode == 'build')
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        ENV_FILE="wrangler.${{ inputs.github-environment }}.jsonc"

        if [ ! -f "$ENV_FILE" ]; then
          echo "::warning::Environment file $ENV_FILE not found, using base wrangler config"
          echo "config-path=" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "Merging $ENV_FILE into base wrangler config..."

        node --eval "
        const fs = require('fs');

        // Strip JSONC comments
        function stripJsonComments(str) {
          return str
            .replace(/\/\*[\s\S]*?\*\//g, '')
            .replace(/\/\/.*/g, '');
        }

        // Deep merge objects
        function deepMerge(target, source) {
          const result = { ...target };
          for (const key of Object.keys(source)) {
            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
              result[key] = deepMerge(result[key] || {}, source[key]);
            } else {
              result[key] = source[key];
            }
          }
          return result;
        }

        // Find base config (jsonc, json, or toml)
        let baseConfig = {};
        let baseFile = '';

        if (fs.existsSync('wrangler.jsonc')) {
          baseFile = 'wrangler.jsonc';
          baseConfig = JSON.parse(stripJsonComments(fs.readFileSync(baseFile, 'utf8')));
        } else if (fs.existsSync('wrangler.json')) {
          baseFile = 'wrangler.json';
          baseConfig = JSON.parse(fs.readFileSync(baseFile, 'utf8'));
        } else if (fs.existsSync('wrangler.toml')) {
          console.error('Error: wrangler.toml found but environment merging requires wrangler.jsonc or wrangler.json');
          console.error('Please convert your wrangler.toml to wrangler.jsonc to use environment-specific configs');
          process.exit(1);
        } else {
          console.error('Error: No wrangler config file found');
          process.exit(1);
        }

        // Read and parse environment config
        const envConfig = JSON.parse(stripJsonComments(fs.readFileSync('$ENV_FILE', 'utf8')));

        // Merge configs
        const merged = deepMerge(baseConfig, envConfig);

        // Write merged config
        const outputPath = '/tmp/wrangler-merged.json';
        fs.writeFileSync(outputPath, JSON.stringify(merged, null, 2));

        console.log('Base config:', baseFile);
        console.log('Environment config: $ENV_FILE');
        console.log('Merged config written to:', outputPath);
        "

        echo "config-path=/tmp/wrangler-merged.json" >> $GITHUB_OUTPUT

    - name: Upload Worker Version
      if: inputs.mode == 'full' || inputs.mode == 'build'
      id: upload
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare-account-id }}
      run: |
        # Use merged config if available
        CONFIG_FLAG=""
        if [ -n "${{ steps.wrangler-config.outputs.config-path }}" ]; then
          CONFIG_FLAG="--config ${{ steps.wrangler-config.outputs.config-path }}"
        fi

        # Upload and capture version ID (use tee to show output in real-time)
        set -o pipefail
        OUTPUT=$(npx wrangler versions upload $CONFIG_FLAG \
          --tag "${{ steps.vars.outputs.tag }}" \
          --message "${{ steps.vars.outputs.message }}" 2>&1 | tee /dev/stderr)

        VERSION_ID=$(echo "$OUTPUT" | grep "Worker Version ID:" | awk '{print $4}')

        if [ -z "$VERSION_ID" ]; then
          echo "::error::Failed to get Worker Version ID from wrangler output"
          exit 1
        fi

        echo "version-id=$VERSION_ID" >> $GITHUB_OUTPUT
        echo "Uploaded version: $VERSION_ID"

    - name: Deploy Worker Version
      if: inputs.mode == 'full' || inputs.mode == 'deploy'
      id: deploy
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare-account-id }}
      run: |
        # Get version ID from upload step or input
        VERSION_ID="${{ steps.upload.outputs.version-id || inputs.version-id }}"

        if [ -z "$VERSION_ID" ]; then
          echo "::error::No version ID available. In deploy mode, you must provide version-id input."
          exit 1
        fi

        echo "Deploying version: $VERSION_ID"

        # Deploy the version at 100%
        npx wrangler versions deploy "${VERSION_ID}@100%" -y

    - name: Upload secrets to Cloudflare
      if: (inputs.mode == 'full' || inputs.mode == 'deploy') && inputs.secrets-json != '' && inputs.secrets-json != '{}'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare-account-id }}
      run: |
        echo '${{ inputs.secrets-json }}' > /tmp/worker-secrets.json
        npx wrangler secret bulk /tmp/worker-secrets.json --name ${{ inputs.worker-name }}
        rm -f /tmp/worker-secrets.json
