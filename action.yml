name: 'Deploy Nuxt to Cloudflare Workers'
description: 'Build and deploy a Nuxt application to Cloudflare Workers with versioned deployments'
author: 'This is Mess'

branding:
  icon: 'upload-cloud'
  color: 'orange'

inputs:
  cloudflare-api-token:
    description: 'Cloudflare API Token with Workers permissions'
    required: true
  cloudflare-account-id:
    description: 'Cloudflare Account ID'
    required: true
  worker-name:
    description: 'Name of the Cloudflare Worker'
    required: true
  working-directory:
    description: 'Path to Nuxt project directory'
    default: '.'
  node-version:
    description: 'Node.js version to use'
    default: '20'
  build-command:
    description: 'Command to build the Nuxt app'
    default: 'npm run build'
  install-command:
    description: 'Command to install dependencies'
    default: 'npm ci'
  package-manager:
    description: 'Package manager to use for caching (npm, pnpm, yarn, or none to disable caching)'
    default: 'npm'
  build-env:
    description: 'JSON object of environment variables for build step'
    required: false
    default: '{}'
  secrets-json:
    description: 'JSON object of secrets to upload to Cloudflare Worker'
    required: false
  deploy-tag:
    description: 'Tag for the deployment (defaults to short SHA)'
    required: false
  deploy-message:
    description: 'Message for the deployment'
    required: false
  github-environment:
    description: 'GitHub environment name - merges wrangler.{github-environment}.jsonc into base config if it exists'
    required: false
  mode:
    description: 'Action mode: full (build+deploy), build (upload only), or deploy (deploy existing version)'
    required: false
    default: 'full'
  version-id:
    description: 'Worker Version ID to deploy (required when mode is deploy)'
    required: false

outputs:
  version-id:
    description: 'The uploaded/deployed Worker Version ID'
    value: ${{ steps.upload.outputs.version-id || inputs.version-id }}
  deploy-tag:
    description: 'The tag used for the deployment'
    value: ${{ steps.vars.outputs.tag }}

runs:
  using: 'composite'
  steps:
    - name: Determine lockfile path
      if: ${{ (inputs.mode == 'full' || inputs.mode == 'build') && inputs.package-manager != 'none' }}
      id: lockfile
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        if [ "${{ inputs.package-manager }}" == "pnpm" ]; then
          echo "path=${{ inputs.working-directory }}/pnpm-lock.yaml" >> $GITHUB_OUTPUT
        elif [ "${{ inputs.package-manager }}" == "yarn" ]; then
          echo "path=${{ inputs.working-directory }}/yarn.lock" >> $GITHUB_OUTPUT
        else
          echo "path=${{ inputs.working-directory }}/package-lock.json" >> $GITHUB_OUTPUT
        fi

    - name: Setup pnpm
      if: ${{ (inputs.mode == 'full' || inputs.mode == 'build') && inputs.package-manager == 'pnpm' }}
      uses: pnpm/action-setup@v4
      with:
        version: latest

    - name: Setup Node.js
      if: ${{ inputs.mode == 'full' || inputs.mode == 'build' }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        cache: ${{ inputs.package-manager != 'none' && inputs.package-manager || '' }}
        cache-dependency-path: ${{ steps.lockfile.outputs.path }}

    - name: Install dependencies
      if: ${{ inputs.mode == 'full' || inputs.mode == 'build' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Auto-detect install command based on package manager if using default
        INSTALL_CMD="${{ inputs.install-command }}"
        if [ "$INSTALL_CMD" == "npm ci" ]; then
          case "${{ inputs.package-manager }}" in
            pnpm) INSTALL_CMD="pnpm install --frozen-lockfile" ;;
            yarn) INSTALL_CMD="yarn install --frozen-lockfile" ;;
          esac
        fi
        $INSTALL_CMD

    - name: Parse build environment variables
      if: ${{ inputs.mode == 'full' || inputs.mode == 'build' }}
      id: build-env
      shell: bash
      run: |
        # Parse JSON and export as environment variables
        echo '${{ inputs.build-env }}' | jq -r 'to_entries | .[] | "export \(.key)=\"\(.value)\""' > /tmp/build-env.sh || true

    - name: Build Worker
      if: ${{ inputs.mode == 'full' || inputs.mode == 'build' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Source build environment variables if they exist
        if [ -f /tmp/build-env.sh ]; then
          source /tmp/build-env.sh
        fi
        ${{ inputs.build-command }}

    - name: Set deployment variables
      if: ${{ inputs.mode == 'full' || inputs.mode == 'build' }}
      id: vars
      shell: bash
      run: |
        # Use provided tag or default to short SHA
        if [ -n "${{ inputs.deploy-tag }}" ]; then
          echo "tag=${{ inputs.deploy-tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
        fi

        # Use provided message or default
        if [ -n "${{ inputs.deploy-message }}" ]; then
          echo "message=${{ inputs.deploy-message }}" >> $GITHUB_OUTPUT
        else
          echo "message=${{ github.actor }} - ${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
        fi

    - name: Merge wrangler config for environment
      id: wrangler-config
      if: ${{ inputs.github-environment != '' && (inputs.mode == 'full' || inputs.mode == 'build') }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        ENV_FILE="wrangler.${{ inputs.github-environment }}.jsonc"

        if [ ! -f "$ENV_FILE" ]; then
          echo "::warning::Environment file $ENV_FILE not found, using Nuxt-generated config as-is"
          exit 0
        fi

        # Find the Nuxt-generated wrangler config
        NITRO_CONFIG=""
        if [ -f ".output/server/wrangler.json" ]; then
          NITRO_CONFIG=".output/server/wrangler.json"
        elif [ -f ".output/wrangler.json" ]; then
          NITRO_CONFIG=".output/wrangler.json"
        else
          echo "::error::No Nuxt-generated wrangler.json found in .output/"
          exit 1
        fi

        echo "Merging $ENV_FILE into $NITRO_CONFIG..."

        # Pass file paths via environment variables to avoid escaping issues
        NITRO_CONFIG="$NITRO_CONFIG" ENV_FILE="$ENV_FILE" node --eval '
        const fs = require("fs");

        // Strip JSONC comments (handles strings correctly to not break URLs)
        function stripJsonComments(str) {
          let result = "";
          let inString = false;
          let inLineComment = false;
          let inBlockComment = false;
          let i = 0;

          while (i < str.length) {
            // Check for string boundaries
            if (!inLineComment && !inBlockComment && str[i] === "\"" && (i === 0 || str[i-1] !== "\\")) {
              inString = !inString;
              result += str[i];
              i++;
              continue;
            }

            // Inside a string, just copy characters
            if (inString) {
              result += str[i];
              i++;
              continue;
            }

            // Check for line comment start
            if (!inBlockComment && str.slice(i, i+2) === "//") {
              inLineComment = true;
              i += 2;
              continue;
            }

            // Check for block comment start
            if (!inLineComment && str.slice(i, i+2) === "/*") {
              inBlockComment = true;
              i += 2;
              continue;
            }

            // Check for block comment end
            if (inBlockComment && str.slice(i, i+2) === "*/") {
              inBlockComment = false;
              i += 2;
              continue;
            }

            // Check for line comment end (newline)
            if (inLineComment && (str[i] === "\n" || str[i] === "\r")) {
              inLineComment = false;
              result += str[i];
              i++;
              continue;
            }

            // Skip characters in comments
            if (inLineComment || inBlockComment) {
              i++;
              continue;
            }

            // Normal character
            result += str[i];
            i++;
          }

          return result;
        }

        // Deep merge objects
        function deepMerge(target, source) {
          const result = { ...target };
          for (const key of Object.keys(source)) {
            if (source[key] && typeof source[key] === "object" && !Array.isArray(source[key])) {
              result[key] = deepMerge(result[key] || {}, source[key]);
            } else {
              result[key] = source[key];
            }
          }
          return result;
        }

        const nitroConfigPath = process.env.NITRO_CONFIG;
        const envFilePath = process.env.ENV_FILE;

        // Read Nuxt-generated config (has main, assets, etc.)
        const nitroConfig = JSON.parse(fs.readFileSync(nitroConfigPath, "utf8"));

        // Read and parse environment config (has bindings, vars, etc.)
        const envConfig = JSON.parse(stripJsonComments(fs.readFileSync(envFilePath, "utf8")));

        // Merge: Nitro config + environment overrides
        const merged = deepMerge(nitroConfig, envConfig);

        // Write merged config back to the Nitro output location
        fs.writeFileSync(nitroConfigPath, JSON.stringify(merged, null, 2));

        console.log("Nitro config:", nitroConfigPath);
        console.log("Environment config:", envFilePath);
        console.log("Merged config written to:", nitroConfigPath);
        '

    - name: Upload Worker Version
      if: ${{ inputs.mode == 'full' || inputs.mode == 'build' }}
      id: upload
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare-account-id }}
      run: |
        # Upload from .output directory where Nuxt generates the wrangler config
        set -o pipefail
        OUTPUT=$(npx wrangler versions upload --cwd .output \
          --name "${{ inputs.worker-name }}" \
          --tag "${{ steps.vars.outputs.tag }}" \
          --message "${{ steps.vars.outputs.message }}" 2>&1 | tee /dev/stderr)

        VERSION_ID=$(echo "$OUTPUT" | grep "Worker Version ID:" | awk '{print $4}')

        if [ -z "$VERSION_ID" ]; then
          echo "::error::Failed to get Worker Version ID from wrangler output"
          exit 1
        fi

        echo "version-id=$VERSION_ID" >> $GITHUB_OUTPUT
        echo "Uploaded version: $VERSION_ID"

    - name: Deploy Worker Version
      if: ${{ inputs.mode == 'full' || inputs.mode == 'deploy' }}
      id: deploy
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare-account-id }}
      run: |
        # Get version ID from upload step or input
        VERSION_ID="${{ steps.upload.outputs.version-id || inputs.version-id }}"

        if [ -z "$VERSION_ID" ]; then
          echo "::error::No version ID available. In deploy mode, you must provide version-id input."
          exit 1
        fi

        echo "Deploying version: $VERSION_ID"

        # Deploy the version at 100%
        npx wrangler versions deploy "${VERSION_ID}@100%" --name "${{ inputs.worker-name }}" -y

    - name: Upload secrets to Cloudflare
      if: ${{ (inputs.mode == 'full' || inputs.mode == 'deploy') && inputs.secrets-json != '' && inputs.secrets-json != '{}' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare-account-id }}
      run: |
        echo '${{ inputs.secrets-json }}' > /tmp/worker-secrets.json
        npx wrangler secret bulk /tmp/worker-secrets.json --name ${{ inputs.worker-name }}
        rm -f /tmp/worker-secrets.json
