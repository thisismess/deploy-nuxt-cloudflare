name: 'Deploy Nuxt to Cloudflare Workers'
description: 'Build and deploy a Nuxt application to Cloudflare Workers with versioned deployments'
author: 'This is Mess'

branding:
  icon: 'upload-cloud'
  color: 'orange'

inputs:
  cloudflare-api-token:
    description: 'Cloudflare API Token with Workers permissions'
    required: true
  cloudflare-account-id:
    description: 'Cloudflare Account ID'
    required: true
  worker-name:
    description: 'Name of the Cloudflare Worker'
    required: true
  working-directory:
    description: 'Path to Nuxt project directory'
    default: '.'
  node-version:
    description: 'Node.js version to use'
    default: '20'
  build-command:
    description: 'Command to build the Nuxt app'
    default: 'npm run build'
  install-command:
    description: 'Command to install dependencies'
    default: 'npm ci'
  package-manager:
    description: 'Package manager to use for caching (npm, pnpm, yarn, or none to disable caching)'
    default: 'npm'
  build-env:
    description: 'JSON object of environment variables for build step'
    required: false
    default: '{}'
  secrets-json:
    description: 'JSON object of secrets to upload to Cloudflare Worker (keys must not overlap with vars in wrangler config)'
    required: false
  deploy-tag:
    description: 'Tag for the deployment (defaults to short SHA)'
    required: false
  deploy-message:
    description: 'Message for the deployment'
    required: false
  github-environment:
    description: 'GitHub environment name - merges wrangler.{github-environment}.jsonc into base config if it exists'
    required: false
  mode:
    description: 'Action mode: full (build+upload+deploy), build (build only, no upload), or deploy (upload+deploy from .output)'
    required: false
    default: 'full'

outputs:
  version-id:
    description: 'The uploaded/deployed Worker Version ID'
    value: ${{ steps.upload.outputs.version-id }}
  deploy-tag:
    description: 'The tag used for the deployment'
    value: ${{ steps.vars.outputs.tag }}

runs:
  using: 'composite'
  steps:
    - name: Determine lockfile path
      if: ${{ (inputs.mode == 'full' || inputs.mode == 'build') && inputs.package-manager != 'none' }}
      id: lockfile
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        if [ "${{ inputs.package-manager }}" == "pnpm" ]; then
          echo "path=${{ inputs.working-directory }}/pnpm-lock.yaml" >> $GITHUB_OUTPUT
        elif [ "${{ inputs.package-manager }}" == "yarn" ]; then
          echo "path=${{ inputs.working-directory }}/yarn.lock" >> $GITHUB_OUTPUT
        else
          echo "path=${{ inputs.working-directory }}/package-lock.json" >> $GITHUB_OUTPUT
        fi

    - name: Setup pnpm
      if: ${{ (inputs.mode == 'full' || inputs.mode == 'build') && inputs.package-manager == 'pnpm' }}
      uses: pnpm/action-setup@v4
      with:
        version: latest

    - name: Setup Node.js
      if: ${{ inputs.mode == 'full' || inputs.mode == 'build' }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        cache: ${{ inputs.package-manager != 'none' && inputs.package-manager || '' }}
        cache-dependency-path: ${{ steps.lockfile.outputs.path }}

    - name: Install dependencies
      if: ${{ inputs.mode == 'full' || inputs.mode == 'build' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Auto-detect install command based on package manager if using default
        INSTALL_CMD="${{ inputs.install-command }}"
        if [ "$INSTALL_CMD" == "npm ci" ]; then
          case "${{ inputs.package-manager }}" in
            pnpm) INSTALL_CMD="pnpm install --frozen-lockfile" ;;
            yarn) INSTALL_CMD="yarn install --frozen-lockfile" ;;
          esac
        fi
        $INSTALL_CMD

    - name: Parse build environment variables
      if: ${{ inputs.mode == 'full' || inputs.mode == 'build' }}
      id: build-env
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Start with user-provided build-env
        echo '${{ inputs.build-env }}' | jq -r 'to_entries | .[] | "export \(.key)=\"\(.value)\""' > /tmp/build-env.sh || true

        # Also extract secrets-json as build env vars
        if [ -n '${{ inputs.secrets-json }}' ] && [ '${{ inputs.secrets-json }}' != '{}' ]; then
          echo "Extracting secrets for build..."
          echo '${{ inputs.secrets-json }}' | jq -r 'to_entries | .[] | "export \(.key)=\"\(.value)\""' >> /tmp/build-env.sh || true
        fi

        # Also extract vars from wrangler environment file if it exists
        ENV_FILE="wrangler.${{ inputs.github-environment }}.jsonc"
        if [ -n "${{ inputs.github-environment }}" ] && [ -f "$ENV_FILE" ]; then
          echo "Extracting vars from $ENV_FILE for build..."

          ENV_FILE="$ENV_FILE" node --eval '
          const fs = require("fs");

          // Strip JSONC comments (handles strings correctly to not break URLs)
          function stripJsonComments(str) {
            let result = "";
            let inString = false;
            let inLineComment = false;
            let inBlockComment = false;
            let i = 0;

            while (i < str.length) {
              if (!inLineComment && !inBlockComment && str[i] === "\"" && (i === 0 || str[i-1] !== "\\")) {
                inString = !inString;
                result += str[i];
                i++;
                continue;
              }
              if (inString) {
                result += str[i];
                i++;
                continue;
              }
              if (!inBlockComment && str.slice(i, i+2) === "//") {
                inLineComment = true;
                i += 2;
                continue;
              }
              if (!inLineComment && str.slice(i, i+2) === "/*") {
                inBlockComment = true;
                i += 2;
                continue;
              }
              if (inBlockComment && str.slice(i, i+2) === "*/") {
                inBlockComment = false;
                i += 2;
                continue;
              }
              if (inLineComment && (str[i] === "\n" || str[i] === "\r")) {
                inLineComment = false;
                result += str[i];
                i++;
                continue;
              }
              if (inLineComment || inBlockComment) {
                i++;
                continue;
              }
              result += str[i];
              i++;
            }
            return result;
          }

          const envFilePath = process.env.ENV_FILE;
          const envConfig = JSON.parse(stripJsonComments(fs.readFileSync(envFilePath, "utf8")));

          // Extract vars and output as shell exports
          if (envConfig.vars) {
            for (const [key, value] of Object.entries(envConfig.vars)) {
              // Escape double quotes in value
              const escaped = String(value).replace(/"/g, "\\\"");
              console.log(`export ${key}="${escaped}"`);
            }
          }
          ' >> /tmp/build-env.sh
        fi

        # Debug: show what will be exported
        echo "::group::Build environment variables"
        if [ -f /tmp/build-env.sh ]; then
          cat /tmp/build-env.sh
        else
          echo "No build environment variables set"
        fi
        echo "::endgroup::"

    - name: Build Worker
      if: ${{ inputs.mode == 'full' || inputs.mode == 'build' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Source build environment variables if they exist
        if [ -f /tmp/build-env.sh ]; then
          source /tmp/build-env.sh
        fi

        # Debug: show NUXT_* variables that will be available during build
        echo "::group::NUXT environment variables for build"
        env | grep -E "^NUXT_" | sort || echo "No NUXT_* variables set"
        echo "::endgroup::"

        ${{ inputs.build-command }}

    - name: Set deployment variables
      id: vars
      shell: bash
      run: |
        # Use provided tag or default to short SHA
        if [ -n "${{ inputs.deploy-tag }}" ]; then
          echo "tag=${{ inputs.deploy-tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
        fi

        # Use provided message or default
        if [ -n "${{ inputs.deploy-message }}" ]; then
          echo "message=${{ inputs.deploy-message }}" >> $GITHUB_OUTPUT
        else
          echo "message=${{ github.actor }} - ${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
        fi

    - name: Merge wrangler config for environment
      id: wrangler-config
      if: ${{ inputs.github-environment != '' && (inputs.mode == 'full' || inputs.mode == 'build') }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        ENV_FILE="wrangler.${{ inputs.github-environment }}.jsonc"

        if [ ! -f "$ENV_FILE" ]; then
          echo "::warning::Environment file $ENV_FILE not found, using Nuxt-generated config as-is"
          exit 0
        fi

        # Find the Nuxt-generated wrangler config
        NITRO_CONFIG=""
        if [ -f ".output/server/wrangler.json" ]; then
          NITRO_CONFIG=".output/server/wrangler.json"
        elif [ -f ".output/wrangler.json" ]; then
          NITRO_CONFIG=".output/wrangler.json"
        else
          echo "::error::No Nuxt-generated wrangler.json found in .output/"
          exit 1
        fi

        echo "Merging $ENV_FILE into $NITRO_CONFIG..."

        # Pass file paths via environment variables to avoid escaping issues
        NITRO_CONFIG="$NITRO_CONFIG" ENV_FILE="$ENV_FILE" node --eval '
        const fs = require("fs");

        // Strip JSONC comments (handles strings correctly to not break URLs)
        function stripJsonComments(str) {
          let result = "";
          let inString = false;
          let inLineComment = false;
          let inBlockComment = false;
          let i = 0;

          while (i < str.length) {
            // Check for string boundaries
            if (!inLineComment && !inBlockComment && str[i] === "\"" && (i === 0 || str[i-1] !== "\\")) {
              inString = !inString;
              result += str[i];
              i++;
              continue;
            }

            // Inside a string, just copy characters
            if (inString) {
              result += str[i];
              i++;
              continue;
            }

            // Check for line comment start
            if (!inBlockComment && str.slice(i, i+2) === "//") {
              inLineComment = true;
              i += 2;
              continue;
            }

            // Check for block comment start
            if (!inLineComment && str.slice(i, i+2) === "/*") {
              inBlockComment = true;
              i += 2;
              continue;
            }

            // Check for block comment end
            if (inBlockComment && str.slice(i, i+2) === "*/") {
              inBlockComment = false;
              i += 2;
              continue;
            }

            // Check for line comment end (newline)
            if (inLineComment && (str[i] === "\n" || str[i] === "\r")) {
              inLineComment = false;
              result += str[i];
              i++;
              continue;
            }

            // Skip characters in comments
            if (inLineComment || inBlockComment) {
              i++;
              continue;
            }

            // Normal character
            result += str[i];
            i++;
          }

          return result;
        }

        // Deep merge objects
        function deepMerge(target, source) {
          const result = { ...target };
          for (const key of Object.keys(source)) {
            if (source[key] && typeof source[key] === "object" && !Array.isArray(source[key])) {
              result[key] = deepMerge(result[key] || {}, source[key]);
            } else {
              result[key] = source[key];
            }
          }
          return result;
        }

        const nitroConfigPath = process.env.NITRO_CONFIG;
        const envFilePath = process.env.ENV_FILE;

        // Read Nuxt-generated config (has main, assets, etc.)
        const nitroConfig = JSON.parse(fs.readFileSync(nitroConfigPath, "utf8"));

        // Read and parse environment config (has bindings, vars, etc.)
        const envConfig = JSON.parse(stripJsonComments(fs.readFileSync(envFilePath, "utf8")));

        // Merge: Nitro config + environment overrides
        const merged = deepMerge(nitroConfig, envConfig);

        // Write merged config back to the Nitro output location
        fs.writeFileSync(nitroConfigPath, JSON.stringify(merged, null, 2));

        console.log("Nitro config:", nitroConfigPath);
        console.log("Environment config:", envFilePath);
        console.log("Merged config written to:", nitroConfigPath);
        '

    - name: Upload Worker Version
      if: ${{ inputs.mode == 'full' || inputs.mode == 'deploy' }}
      id: upload
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare-account-id }}
      run: |
        # Upload from .output directory where Nuxt generates the wrangler config
        set -o pipefail
        OUTPUT=$(npx wrangler versions upload --cwd .output \
          --name "${{ inputs.worker-name }}" \
          --tag "${{ steps.vars.outputs.tag }}" \
          --message "${{ steps.vars.outputs.message }}" 2>&1 | tee /dev/stderr)

        VERSION_ID=$(echo "$OUTPUT" | grep "Worker Version ID:" | awk '{print $4}')

        if [ -z "$VERSION_ID" ]; then
          echo "::error::Failed to get Worker Version ID from wrangler output"
          exit 1
        fi

        echo "version-id=$VERSION_ID" >> $GITHUB_OUTPUT
        echo "Uploaded version: $VERSION_ID"

    - name: Deploy Worker Version
      if: ${{ inputs.mode == 'full' || inputs.mode == 'deploy' }}
      id: deploy
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare-account-id }}
      run: |
        VERSION_ID="${{ steps.upload.outputs.version-id }}"

        echo "Deploying version: $VERSION_ID"

        # Deploy the version at 100%
        npx wrangler versions deploy "${VERSION_ID}@100%" --name "${{ inputs.worker-name }}" -y

    - name: Upload secrets to Cloudflare
      if: ${{ (inputs.mode == 'full' || inputs.mode == 'deploy') && inputs.secrets-json != '' && inputs.secrets-json != '{}' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare-api-token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare-account-id }}
        SECRETS_JSON: ${{ inputs.secrets-json }}
      run: |
        # Collect var names from wrangler env config to filter out conflicts
        VAR_NAMES="[]"
        ENV_FILE="wrangler.${{ inputs.github-environment }}.jsonc"
        if [ -n "${{ inputs.github-environment }}" ] && [ -f "$ENV_FILE" ]; then
          VAR_NAMES=$(ENV_FILE="$ENV_FILE" node --eval '
          const fs = require("fs");
          function stripJsonComments(str) {
            let result = "", inString = false, inLine = false, inBlock = false, i = 0;
            while (i < str.length) {
              if (!inLine && !inBlock && str[i] === "\"" && (i === 0 || str[i-1] !== "\\")) { inString = !inString; result += str[i]; i++; continue; }
              if (inString) { result += str[i]; i++; continue; }
              if (!inBlock && str.slice(i,i+2) === "//") { inLine = true; i += 2; continue; }
              if (!inLine && str.slice(i,i+2) === "/*") { inBlock = true; i += 2; continue; }
              if (inBlock && str.slice(i,i+2) === "*/") { inBlock = false; i += 2; continue; }
              if (inLine && (str[i] === "\n" || str[i] === "\r")) { inLine = false; result += str[i]; i++; continue; }
              if (inLine || inBlock) { i++; continue; }
              result += str[i]; i++;
            }
            return result;
          }
          const cfg = JSON.parse(stripJsonComments(fs.readFileSync(process.env.ENV_FILE, "utf8")));
          console.log(JSON.stringify(Object.keys(cfg.vars || {})));
          ')
        fi

        # Filter out secrets that conflict with vars, then upload each individually
        echo "$SECRETS_JSON" | VAR_NAMES="$VAR_NAMES" node --eval '
        const secrets = JSON.parse(require("fs").readFileSync("/dev/stdin", "utf8"));
        const varNames = new Set(JSON.parse(process.env.VAR_NAMES));
        for (const [k, v] of Object.entries(secrets)) {
          if (varNames.has(k)) {
            console.error(`Skipping secret "${k}" - already defined as a var in wrangler config`);
          } else {
            console.log(`${k}\t${v}`);
          }
        }
        ' | while IFS=$'\t' read -r KEY VALUE; do
          echo "Uploading secret: $KEY"
          echo "$VALUE" | npx wrangler secret put "$KEY" --name "${{ inputs.worker-name }}"
        done
